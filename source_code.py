# -*- coding: utf-8 -*-
"""source_code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dRB1Ii6n3NsHGUoew9zj_gNg0KxXLE86
"""

import time
import resource
from collections import deque

moves = {
    0: [3, 1],
    1: [4, 2, 0],
    2: [5, 1],
    3: [6, 4, 0],
    4: [7, 5, 3, 1],
    5: [8, 6, 2],
    6: [7, 3],
    7: [8, 6, 4],
    8: [7, 5]
}

def getPossibleMoves(state):
    return moves[state.index(0)]

def swap(state, i, j):
    state[i], state[j] = state[j], state[i]
    return state

def dfs(initialState, goalState):
    visited = set()
    stack = deque([(initialState, [])])
    nodes_visited = 0

    while stack:
        currentState, path = stack.pop()
        visited.add(tuple(currentState))
        nodes_visited += 1

        if currentState == goalState:
            return path + [currentState], nodes_visited

        for move in getPossibleMoves(currentState):
            newState = swap(currentState[:], currentState.index(0), move)
            if tuple(newState) not in visited:
                stack.append((newState, path + [currentState]))

    return "Oops! No Solution Found", nodes_visited

print("Enter the initial state of the 8 Puzzle (use 0 to represent the blank space)")
inputData = input().split(" ")
initialState = [int(num) for num in inputData]
print("Enter the goal state of the 8 Puzzle (use 0 to represent the blank space)")
inputData2 = input().split(" ")
goalState = [int(num) for num in inputData2]

t1 = time.perf_counter()
solution_path, nodes_visited = dfs(initialState, goalState)
t2 = time.perf_counter()

# Calculating system resources
usage = resource.getrusage(resource.RUSAGE_SELF)
memory_usage = usage[2] / 1024  # Memory usage in kilobytes

print('Time Taken:', t2 - t1)
print('Number of Nodes Visited:', nodes_visited)
print('Path Cost:', len(solution_path) - 1)
print('Memory Usage:', memory_usage, 'KB')

for state in solution_path:
    print(state[:3])
    print(state[3:6])
    print(state[6:])
    print()

import time
import resource
from collections import deque

moves = {
    0: [3, 1],
    1: [4, 2, 0],
    2: [5, 1],
    3: [6, 4, 0],
    4: [7, 5, 3, 1],
    5: [8, 6, 2],
    6: [7, 3],
    7: [8, 6, 4],
    8: [7, 5]
}

def getPossibleMoves(state):
    return moves[state.index(0)]

def swap(state, i, j):
    state[i], state[j] = state[j], state[i]
    return state

def dfs_recursive_limit(state, goalState, limit, path, visited):
    if state == goalState:
        return True, path

    if limit == 0:
        return False, None

    visited.add(tuple(state))

    for move in getPossibleMoves(state):
        newState = swap(state[:], state.index(0), move)
        if tuple(newState) not in visited:
            found, result_path = dfs_recursive_limit(newState, goalState, limit - 1, path + [state], visited)
            if found:
                return True, result_path

    return False, None

def iddfs(initialState, goalState):
    nodes_visited = 0
    for depth_limit in range(len(initialState)**2):  # Adjust the depth limit as needed
        visited = set()
        found, path = dfs_recursive_limit(initialState, goalState, depth_limit, [], visited)
        nodes_visited += len(visited)
        if found:
            return path + [goalState], nodes_visited

    return "Oops! No Solution Found", nodes_visited

print("Enter the initial state of the 8 Puzzle (use 0 to represent the blank space)")
inputData = input().split(" ")
initialState = [int(num) for num in inputData]
print("Enter the goal state of the 8 Puzzle (use 0 to represent the blank space)")
inputData2 = input().split(" ")
goalState = [int(num) for num in inputData2]

t1 = time.perf_counter()
solution_path, nodes_visited = iddfs(initialState, goalState)
t2 = time.perf_counter()

# Calculating system resources
usage = resource.getrusage(resource.RUSAGE_SELF)
memory_usage = usage[2] / 1024  # Memory usage in kilobytes

print('Time Taken:', t2 - t1)
print('Number of Nodes Visited:', nodes_visited)
print('Path Cost:', len(solution_path) - 1)
print('Memory Usage:', memory_usage, 'KB')

for state in solution_path:
    print(state[:3])
    print(state[3:6])
    print(state[6:])
    print()

import time
import resource
from collections import deque

moves = {
    0: [3, 1],
    1: [4, 2, 0],
    2: [5, 1],
    3: [6, 4, 0],
    4: [7, 5, 3, 1],
    5: [8, 6, 2],
    6: [7, 3],
    7: [8, 6, 4],
    8: [7, 5]
}

def getPossibleMoves(state):
    return moves[state.index(0)]

def swap(state, i, j):
    state[i], state[j] = state[j], state[i]
    return state

def bfs(initialState, goalState):
    visited = set()
    queue = deque([(initialState, [])])
    nodes_visited = 0

    while queue:
        currentState, path = queue.popleft()
        visited.add(tuple(currentState))
        nodes_visited += 1

        if currentState == goalState:
            return path + [currentState], nodes_visited

        for move in getPossibleMoves(currentState):
            newState = swap(currentState[:], currentState.index(0), move)
            if tuple(newState) not in visited:
                queue.append((newState, path + [currentState]))

    return "Oops! No Solution Found", nodes_visited

print("Enter the initial state of the 8 Puzzle (use 0 to represent the blank space)")
inputData = input().split(" ")
initialState = [int(num) for num in inputData]
print("Enter the goal state of the 8 Puzzle (use 0 to represent the blank space)")
inputData2 = input().split(" ")
goalState = [int(num) for num in inputData2]

t1 = time.perf_counter()
solution_path, nodes_visited = bfs(initialState, goalState)
t2 = time.perf_counter()

# Calculating system resources
usage = resource.getrusage(resource.RUSAGE_SELF)
memory_usage = usage[2] / 1024  # Memory usage in kilobytes

print('Time Taken:', t2 - t1)
print('Number of Nodes Visited:', nodes_visited)
print('Path Cost:', len(solution_path) - 1)
print('Memory Usage:', memory_usage, 'KB')

for state in solution_path:
    print(state[:3])
    print(state[3:6])
    print(state[6:])
    print()

import time
import resource
from heapq import heappush, heappop

moves = {
    0: [3, 1],
    1: [4, 2, 0],
    2: [5, 1],
    3: [6, 4, 0],
    4: [7, 5, 3, 1],
    5: [8, 6, 2],
    6: [7, 3],
    7: [8, 6, 4],
    8: [7, 5]
}

def getPossibleMoves(state):
    return moves[state.index(0)]

def swap(state, i, j):
    state[i], state[j] = state[j], state[i]
    return state

def ucs(initialState, goalState):
    visited = set()
    heap = [(0, initialState, [])]
    nodes_visited = 0

    while heap:
        currentPathCost, currentState, path = heappop(heap)
        nodes_visited += 1

        if currentState == goalState:
            return path + [currentState], nodes_visited

        visited.add(tuple(currentState))

        for move in getPossibleMoves(currentState):
            newState = swap(currentState[:], currentState.index(0), move)
            if tuple(newState) not in visited:
                newPath = path + [currentState]
                newCost = currentPathCost + 1
                heappush(heap, (newCost, newState, newPath))

    return "Oops! No Solution Found", nodes_visited

print("Enter the initial state of the 8 Puzzle (use 0 to represent the blank space)")
inputData = input().split(" ")
initialState = [int(num) for num in inputData]
print("Enter the goal state of the 8 Puzzle (use 0 to represent the blank space)")
inputData2 = input().split(" ")
goalState = [int(num) for num in inputData2]

t1 = time.perf_counter()
solution_path, nodes_visited = ucs(initialState, goalState)
t2 = time.perf_counter()

# Calculating system resources
usage = resource.getrusage(resource.RUSAGE_SELF)
memory_usage = usage[2] / 1024  # Memory usage in kilobytes

print('Time Taken:', t2 - t1)
print('Number of Nodes Visited:', nodes_visited)
print('Path Cost:', len(solution_path) - 1)
print('Memory Usage:', memory_usage, 'KB')

for state in solution_path:
    print(state[:3])
    print(state[3:6])
    print(state[6:])
    print()